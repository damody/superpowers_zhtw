---
name: systematic-debugging
description: 當遇到任何 bug、測試失敗或意外行為時使用,在提議修復方案之前
---

# 系統除錯

## 概述

隨機修復浪費時間並創造新 bug。快速補丁掩蓋底層問題。

**核心原則:** 總是在嘗試修復前找到根本原因。症狀修復就是失敗。

**違反此流程的字面意義就是違反除錯的精神。**

## 鐵律

```
沒有根本原因調查就不能進行修復
```

如果您還沒有完成階段 1,就不能提議修復方案。

## 何時使用

用於任何技術問題:
- 測試失敗
- 生產環境的 bug
- 意外行為
- 性能問題
- 構建失敗
- 整合問題

**特別在以下情況使用:**
- 在時間壓力下(緊急情況使猜測變得誘人)
- 「只是一個快速修復」看起來很明顯
- 您已經嘗試過多個修復
- 之前的修復沒有效果
- 您不完全理解問題

**不要跳過當:**
- 問題看起來很簡單(簡單的 bug 也有根本原因)
- 您趕時間(倉促保證返工)
- 經理要求立即修復(系統性比混亂更快)

## 四個階段

您必須在繼續下一個階段之前完成每個階段。

### 階段 1：根本原因調查

**在嘗試任何修復之前:**

1. **仔細閱讀錯誤訊息**
   - 不要跳過錯誤或警告
   - 它們通常包含確切的解決方案
   - 完整閱讀堆疊追蹤
   - 注意行號、文件路徑、錯誤代碼

2. **一致性重現**
   - 您能可靠地觸發它嗎?
   - 確切的步驟是什麼?
   - 每次都會發生嗎?
   - 如果無法重現 → 收集更多數據,不要猜測

3. **檢查最近的更改**
   - 什麼更改可能導致這個問題?
   - Git diff,最近的提交
   - 新依賴,配置更改
   - 環境差異

4. **在多組件系統中收集證據**

   **當系統有多個組件時(CI → 構建 → 簽名,API → 服務 → 資料庫):**

   **在提議修復前,添加診斷儀器:**
   ```
   對於每個組件邊界:
     - 記錄進入組件的數據
     - 記錄離開組件的數據
     - 驗證環境/配置傳播
     - 檢查每層的狀態

   運行一次以收集證據,顯示在哪裡中斷
   然後分析證據以識別失敗的組件
   然後調查該特定組件
   ```

   **範例(多層系統):**
   ```bash
   # 第 1 層:工作流程
   echo "=== Secrets available in workflow: ==="
   echo "IDENTITY: ${IDENTITY:+SET}${IDENTITY:-UNSET}"

   # 第 2 層:構建腳本
   echo "=== Env vars in build script: ==="
   env | grep IDENTITY || echo "IDENTITY not in environment"

   # 第 3 層:簽名腳本
   echo "=== Keychain state: ==="
   security list-keychains
   security find-identity -v

   # 第 4 層:實際簽名
   codesign --sign "$IDENTITY" --verbose=4 "$APP"
   ```

   **這揭示了:** 哪一層失敗(secrets → workflow ✓, workflow → build ✗)

5. **追蹤數據流**

   **當錯誤在調用堆疊深處時:**

   查看此目錄中的 `root-cause-tracing.md` 以獲取完整的向後追蹤技術。

   **快速版本:**
   - 錯誤值源自哪裡?
   - 什麼用錯誤值調用了這個?
   - 繼續向上追蹤直到找到源頭
   - 在源頭修復,而非在症狀處

### 階段 2：模式分析

**在修復前找到模式:**

1. **找到可運作的範例**
   - 在同一代碼庫中找到類似的可運作代碼
   - 什麼與損壞的類似但能運作?

2. **與參考比較**
   - 如果實作模式,完整閱讀參考實作
   - 不要略讀 - 閱讀每一行
   - 在應用前完全理解模式

3. **識別差異**
   - 可運作和損壞之間有什麼不同?
   - 列出每個差異,無論多小
   - 不要假設「那不可能有關係」

4. **理解依賴**
   - 這需要哪些其他組件?
   - 什麼設置、配置、環境?
   - 它做了什麼假設?

### 階段 3：假設和測試

**科學方法:**

1. **形成單一假設**
   - 清楚陳述:「我認為 X 是根本原因,因為 Y」
   - 寫下來
   - 要具體,不要模糊

2. **最小化測試**
   - 做最小可能的更改來測試假設
   - 一次一個變量
   - 不要一次修復多個東西

3. **在繼續前驗證**
   - 有效嗎?是 → 階段 4
   - 沒效果?形成新假設
   - 不要在上面添加更多修復

4. **當您不知道時**
   - 說「我不理解 X」
   - 不要假裝知道
   - 尋求幫助
   - 進行更多研究

### 階段 4：實作

**修復根本原因,而非症狀:**

1. **創建失敗的測試案例**
   - 最簡單的重現
   - 如果可能,使用自動化測試
   - 如果沒有框架,使用一次性測試腳本
   - 修復前必須有
   - 使用 `superpowers:test-driven-development` 技能編寫適當的失敗測試

2. **實作單一修復**
   - 解決已識別的根本原因
   - 一次一個更改
   - 沒有「既然在這裡」的改進
   - 沒有捆綁的重構

3. **驗證修復**
   - 測試現在通過了嗎?
   - 沒有其他測試損壞?
   - 問題實際上解決了嗎?

4. **如果修復不起作用**
   - 停止
   - 計數:您嘗試了多少次修復?
   - 如果 < 3:返回階段 1,用新資訊重新分析
   - **如果 ≥ 3:停止並質疑架構(下面的步驟 5)**
   - 不要在沒有架構討論的情況下嘗試修復 #4

5. **如果 3+ 次修復失敗:質疑架構**

   **指示架構問題的模式:**
   - 每個修復都揭示不同地方的新共享狀態/耦合/問題
   - 修復需要「大規模重構」才能實作
   - 每個修復在其他地方創建新症狀

   **停止並質疑基本原理:**
   - 這個模式從根本上合理嗎?
   - 我們是否「僅憑慣性堅持它」?
   - 我們應該重構架構還是繼續修復症狀?

   **在嘗試更多修復前與您的人類夥伴討論**

   這不是一個失敗的假設 - 這是一個錯誤的架構。

## 紅旗警示 - 停止並遵循流程

如果您發現自己在想:
- 「現在快速修復,稍後調查」
- 「只是試著更改 X,看看是否有效」
- 「添加多個更改,運行測試」
- 「跳過測試,我會手動驗證」
- 「可能是 X,讓我修復那個」
- 「我不完全理解,但這可能有效」
- 「模式說 X,但我會以不同方式調整它」
- 「這裡是主要問題:[列出修復而沒有調查]」
- 在追蹤數據流之前提議解決方案
- **「再嘗試一次修復」(已經嘗試過 2+ 次時)**
- **每個修復在不同地方揭示新問題**

**所有這些意味著:停止。返回階段 1。**

**如果 3+ 次修復失敗:** 質疑架構(見階段 4.5)

## 您人類夥伴的信號表示您做錯了

**留意這些重定向:**
- 「那沒有發生嗎?」- 您在沒有驗證的情況下假設了
- 「它會向我們顯示...嗎?」- 您應該添加證據收集
- 「停止猜測」- 您在沒有理解的情況下提議修復
- 「深度思考這個」- 質疑基本原理,而非僅症狀
- 「我們卡住了?」(沮喪)- 您的方法不起作用

**當您看到這些時:** 停止。返回階段 1。

## 常見藉口

| 藉口 | 現實 |
|------|------|
| 「問題很簡單,不需要流程」 | 簡單問題也有根本原因。流程對簡單 bug 很快。 |
| 「緊急情況,沒時間進行流程」 | 系統除錯比猜測和檢查的混亂更快。 |
| 「先試試這個,然後調查」 | 第一次修復設定了模式。從一開始就做對。 |
| 「我會在確認修復有效後寫測試」 | 未測試的修復不會持久。先測試證明它。 |
| 「一次多個修復節省時間」 | 無法隔離什麼有效。導致新 bug。 |
| 「參考太長,我會調整模式」 | 部分理解保證 bug。完整閱讀。 |
| 「我看到問題了,讓我修復它」 | 看到症狀 ≠ 理解根本原因。 |
| 「再試一次修復」(在 2+ 次失敗後) | 3+ 次失敗 = 架構問題。質疑模式,不要再次修復。 |

## 快速參考

| 階段 | 關鍵活動 | 成功標準 |
|------|---------|---------|
| **1. 根本原因** | 閱讀錯誤,重現,檢查更改,收集證據 | 理解是什麼和為什麼 |
| **2. 模式** | 找到可運作的範例,比較 | 識別差異 |
| **3. 假設** | 形成理論,最小化測試 | 確認或新假設 |
| **4. 實作** | 創建測試,修復,驗證 | Bug 解決,測試通過 |

## 當流程揭示「沒有根本原因」

如果系統調查揭示問題確實是環境的、與時間相關的或外部的:

1. 您已完成流程
2. 記錄您調查的內容
3. 實作適當的處理(重試、超時、錯誤訊息)
4. 添加監控/日誌以供未來調查

**但是:** 95% 的「沒有根本原因」案例是不完整的調查。

## 支持技術

這些技術是系統除錯的一部分,可在此目錄中使用:

- **`root-cause-tracing.md`** - 向後追蹤 bug 通過調用堆疊以找到原始觸發器
- **`defense-in-depth.md`** - 在找到根本原因後在多個層添加驗證
- **`condition-based-waiting.md`** - 用條件輪詢替換任意超時

**相關技能:**
- **superpowers:test-driven-development** - 用於創建失敗的測試案例(階段 4,步驟 1)
- **superpowers:verification-before-completion** - 在聲稱成功前驗證修復有效

## 真實世界影響

來自除錯會話:
- 系統方法: 15-30 分鐘修復
- 隨機修復方法: 2-3 小時的混亂
- 首次修復成功率: 95% vs 40%
- 引入的新 bug: 接近零 vs 常見
